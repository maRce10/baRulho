stn <- X$start[y] - mar
enn <- X$end[y] + mar
mar1 <- mar
if (stn < 0) {
mar1 <- mar1  + stn
stn <- 0
}
mar2 <- mar1 + X$end[y] - X$start[y]
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
r <- warbleR::read_wave(X = X, index = y, from = stn, to = enn)
# read clip with signal
signal <- warbleR::read_wave(X = X, index = y)
# add band-pass frequency filter
if (!is.null(bp)) {
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
}
# get RMS for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
# cut ambient noise before signal
noise1 <- seewave::cutw(r, from =  0, to = mar1, f = f)
# get RMS for background noise
bg.env <- seewave::env(noise1, f = f, envt = "abs", plot = FALSE)
}
return(list(sig.env = sig.env, bg.env = bg.env))
})
# add sound file selec column and names to envelopes (weird column name so it does not overwrite user columns)
X$TEMP....y <- names(envs) <- paste(X$sound.files, X$selec, sep = "-")
X$TEMP....y
# calculate SNR
X$signal.to.noise.ratio <- sapply(1:nrow(X), function(y){
if (X$signal.type[y] != "ambient"){
# signal RMS
sig_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$sig.env)
# get reference ambient noise RMS
if (noise.ref == "adjacent"){
bg_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$bg.env)
} else {
# get envelopes from ambient selections
bg_envs <- sapply(envs[X$TEMP....y[X$sound.files == X$sound.files[y] & X$signal.type == "ambient"]], "[", 'sig.env')
# get mean RMS from combined envelopes
bg_RMS <- seewave::rms(unlist(sapply(bg_envs, as.vector)))
}
# Calculate signal-to-noise ratio
snr <- - 20 * log10(sig_RMS / bg_RMS)
return(snr)
} else return(NA) # return NA if current row is noise
})
y = 1
X$signal.type[y]
# signal RMS
sig_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$sig.env)
sig_RMS
envs[X$TEMP....y[X$sound.files == X$sound.files[y] & X$signal.type == "ambient"]]
envs
X$TEMP....y
X$TEMP....y[X$sound.files == X$sound.files[y] & X$signal.type == "ambient"]
y
X$signal.type[y]
X$signal.type[y] != "ambient"
# signal RMS
sig_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$sig.env)
sig_RMS
bg_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$bg.env)
bg_RMS
# get envelopes from ambient selections
bg_envs <- sapply(envs[X$TEMP....y[X$sound.files == X$sound.files[y] & X$signal.type == "ambient"]], "[", 'sig.env')
bg_envs
envs
names(envs)
y
X$sound.files
X$sound.files == X$sound.files[y]
X$sound.files == X$sound.files[y] & X$signal.type == "ambient"
X$TEMP....y[X$sound.files == X$sound.files[y] & !X$signal.type == "ambient"]
X$sound.files == X$sound.files[y]
X$sound.files
# get envelopes from ambient selections
bg_envs <- sapply(envs[X$TEMP....y[X$sound.files == X$sound.files[y] & !X$signal.type == "ambient"]], "[", 'sig.env')
bg_envs
# get mean RMS from combined envelopes
bg_RMS <- seewave::rms(unlist(sapply(bg_envs, as.vector)))
bg_RMS
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
a <- envs[X$TEMP....y[X$sound.files == X$sound.files[y] & !X$signal.type == "ambient"]]
a
names(a)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
snra
# get envelopes from ambient selections
bg_envs <- sapply(envs[X$TEMP....y[X$sound.files == X$sound.files[y] & !X$signal.type == "ambient"]], "[", 'sig.env')
bg_envs
# get mean RMS from combined envelopes
bg_RMS <- seewave::rms(unlist(sapply(bg_envs, as.vector)))
bg_RMS
sig_RMS
envs[[X$TEMP....y[y]]]$sig.env
envs[[X$TEMP....y[y]]]
y = 1
if (noise.ref == "custom"){
# read signal clip
signal <- warbleR::read_wave(X = X, index = y)
# add band-pass frequency filter
if (!is.null(bp)) {
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
}
# get RMS for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
bg.env <- NA
}
noise.ref == "adjacent"
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# read sample rate
f <- r$sample.rate
# set margin to half of signal duration
if (eq.dur) mar <- (X$end[y] - X$start[y]) else if(all(argus != "mar")) stop("'mar' must be provided when 'eq.dur = FALSE'")
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
enn <- X$end[y] + mar
mar1 <- mar
if (stn < 0) {
mar1 <- mar1  + stn
stn <- 0
}
mar2 <- mar1 + X$end[y] - X$start[y]
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
r <- warbleR::read_wave(X = X, index = y, from = stn, to = enn)
# read clip with signal
signal <- warbleR::read_wave(X = X, index = y)
signal
r
# get envelop for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
# cut ambient noise before signal
noise1 <- seewave::cutw(r, from =  0, to = mar1, f = f)
# get envelop for background noise
bg.env <- seewave::env(noise1, f = f, envt = "abs", plot = FALSE)
bg.env
envs <- warbleR:::pblapply_wrblr_int(X = 1:nrow(X), pbar = pb, cl = cl, FUN = function(y)   {
if (noise.ref == "custom"){
# read signal clip
signal <- warbleR::read_wave(X = X, index = y)
# add band-pass frequency filter
if (!is.null(bp)) {
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
}
# get RMS for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
bg.env <- NA
}
if (noise.ref == "adjacent"){
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# read sample rate
f <- r$sample.rate
# set margin to half of signal duration
if (eq.dur) mar <- (X$end[y] - X$start[y]) else if(all(argus != "mar")) stop("'mar' must be provided when 'eq.dur = FALSE'")
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
enn <- X$end[y] + mar
mar1 <- mar
if (stn < 0) {
mar1 <- mar1  + stn
stn <- 0
}
mar2 <- mar1 + X$end[y] - X$start[y]
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
r <- warbleR::read_wave(X = X, index = y, from = stn, to = enn)
# read clip with signal
signal <- warbleR::read_wave(X = X, index = y)
# add band-pass frequency filter
if (!is.null(bp)) {
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
}
# get envelop for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
# cut ambient noise before signal
noise1 <- seewave::cutw(r, from =  0, to = mar1, f = f)
# get envelop for background noise
bg.env <- seewave::env(noise1, f = f, envt = "abs", plot = FALSE)
}
return(list(sig.env = sig.env, bg.env = bg.env))
})
envs
# add sound file selec column and names to envelopes (weird column name so it does not overwrite user columns)
X$TEMP....y <- names(envs) <- paste(X$sound.files, X$selec, sep = "-")
head(X)
head(as.data.frame(X))
y = 1
X$signal.type[y]
X$TEMP....y
X$TEMP....y[y]
# signal RMS
sig_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$sig.env)
bg_RMS <- seewave::rms(envs[[X$TEMP....y[y]]]$bg.env)
bg_RMS
sig_RMS
# Calculate signal-to-noise ratio
snr <- - 20 * log10(sig_RMS / bg_RMS)
snr
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
pe2 <- sig2noise(pe, mar = 0.5)
aggregate(SNR ~ distance, pe2, mean)
pe2 <- sig2noise(pe, mar = 0.5, type = 2)
pe2
aggregate(SNR ~ distance, pe2, mean)
pe2 <- sig2noise(pe, mar = 0.5, type = 2, in.dB = TRUE)
pe2
aggregate(SNR ~ distance, pe2, mean)
pe2 <- sig2noise(pe, mar = 0.5, type = 2, in.dB = FALSE)
aggregate(SNR ~ distance, pe2, mean)
pe2 <- sig2noise(pe, mar = 0.5, type = 2, before = TRUE)
aggregate(SNR ~ distance, pe2, mean)
bg_RMS
sig_RMS
seewave::rms(envs[[X$TEMP....y[y]]]$sig.env)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
snra <- signal_to_noise_ratio(X = pe, mar = 0.01, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
snra <- signal_to_noise_ratio(X = pe, mar = 0.000001, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
snra <- signal_to_noise_ratio(X = pe, mar = 0.000001, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
pe2 <- sig2noise(pe, mar = 0.5, type = 2, before = TRUE, in.dB = TRUE)
aggregate(SNR ~ distance, pe2, mean)
sig_RMS
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
r
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# read sample rate
f <- r$sample.rate
# set margin to half of signal duration
if (eq.dur) mar <- (X$end[y] - X$start[y]) else if(all(argus != "mar")) stop("'mar' must be provided when 'eq.dur = FALSE'")
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
enn <- X$end[y] + mar
mar1 <- mar
if (stn < 0) {
mar1 <- mar1  + stn
stn <- 0
}
mar2 <- mar1 + X$end[y] - X$start[y]
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
noise_sig <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# add band-pass frequency filter
if (!is.null(bp)) {
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
noise_sig <- seewave::ffilter(noise_sig, f = f, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
}
noise_sig
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = F, bp = "freq.range")
aggregate(signal.to.noise.ratio ~ distance, snra, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R")
FUN <- "excess_attenuation"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = playback_est
print("using method 1")
(ea <- excess_attenuation(X = playback_est))
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est))
ea$excess.attenuation
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
ea$excess.attenuation
(ea <- excess_attenuation(X = playback_est))
ea$excess.attenuation
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/spcc_align.R")
X = playback_est
parallel = 1
pb = TRUE
method = 1
type = "Marten"
bp = NULL
output = "est"
hop.size = 1
wl = NULL
ovlp = 70
# is extended sel tab
if (!warbleR::is_extended_selection_table(X))
stop("'X' must be and extended selection table")
# If parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
#check output
if (!any(output %in% c("est", "data.frame"))) stop("'output' must be 'est' or 'data.frame'")
# hopsize
if (!is.numeric(hop.size) | hop.size < 0) stop("'hop.size' must be a positive number")
# adjust wl based on hope.size
if (is.null(wl))
wl <- round(attr(X, "check.results")$sample.rate[1] * hop.size, 0)
# make wl even if odd
if (!(wl %% 2) == 0) wl <- wl + 1
# If method is not numeric
if (!is.numeric(method)) stop("'method' must be a numeric vector of length 1")
if (!any(method %in% 1:2)) stop("'method' must be either 1 or 2")
# check signal.type column
if (is.null(X$signal.type)) stop("'X' must containe a 'signal.type' column")
# add sound file selec column and names to X (weird column name so it does not overwrite user columns)
X <- prep_X_bRlo_int(X, method = method, parallel = parallel, pb = pb)
X
y = 1
ovlp
# read signal clip
clp <- warbleR::read_wave(X = X, index = y)
# define bandpass based on reference
bp <- c(X$bottom.freq[X$TEMP....sgnl == X$reference[y]], X$top.freq[X$TEMP....sgnl == X$reference[y]])
# bandpass filter
clp <- seewave::ffilter(clp, from = bp[1] * 1000,
ovlp = ovlp, to = bp[2] * 1000, bandpass = TRUE,
wl = wl, output = "Wave")
# get RMS for signal
sigRMS <- seewave::rms(seewave::env(clp, f = clp@samp.rate, envt = "abs", plot = FALSE))
sigRMS <- 20 * log10(sigRMS)
sigRMS
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
data.frame(X[y, , drop = FALSE], sigRMS)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
# run loop apply function
RMS <- warbleR:::pblapply_wrblr_int(X = 1:nrow(X), pbar = pb, cl = cl, FUN = function(y)  rms_FUN(y, bp, wl, ovlp))
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
# run loop apply function
RMS <- warbleR:::pblapply_wrblr_int(X = 1:nrow(X), pbar = pb, cl = cl, FUN = function(y)  rms_FUN(y, bp, wl, ovlp))
# function to measure RMS for signal and noise
rms_FUN <- function(y, bp, wl, ovlp){
# read signal clip
clp <- warbleR::read_wave(X = X, index = y)
# define bandpass based on reference
bp <- c(X$bottom.freq[X$TEMP....sgnl == X$reference[y]], X$top.freq[X$TEMP....sgnl == X$reference[y]])
# bandpass filter
clp <- seewave::ffilter(clp, from = bp[1] * 1000,
ovlp = ovlp, to = bp[2] * 1000, bandpass = TRUE,
wl = wl, output = "Wave")
# get RMS for signal
sigRMS <- seewave::rms(seewave::env(clp, f = clp@samp.rate, envt = "abs", plot = FALSE))
sigRMS <- 20 * log10(sigRMS)
return(data.frame(X[y, , drop = FALSE], sigRMS))
}
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
# run loop apply function
RMS <- warbleR:::pblapply_wrblr_int(X = 1:nrow(X), pbar = pb, cl = cl, FUN = function(y)  rms_FUN(y, bp, wl, ovlp))
# put in a data frame
RMS_df <- do.call(rbind, RMS)
# split by signal ID
RMS_list <- split(RMS_df, RMS_df$signal.type)
RMS_list
Y <- RMS_list[[1]]
Y
meth = method
tp = type
# extract RMS of signal and background references
sig_RMS_REF <- Y$sigRMS[which.min(Y$distance)]
sig_RMS_REF
dist_REF <- Y$distance[which.min(Y$distance)]
dist_REF
sig_RMS_REF
Y$sigRMS
term1
# term 1: decrease in signal amplitude (RMS) of reference (Ref) vs re-recorded (RR)
term1 <- sig_RMS_REF - Y$sigRMS
term1
# lost due to spheric spreading
term2 <- -20 * log10(1 / Y$distance)
term2
# lost due to spheric spreading
term2 <- -20 * log10(1 / (Y$distance - dist_REF))
# distance traveled by sound
term3 <- Y$distance - dist_REF
# excess attenuation = (total attenuation - spheric spreading attenuation) / distance
ea <- (term1 + term2) / term3
ea
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
aggregate(excess.attenuation ~ distance, ea, mean)
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
aggregate(excess.attenuation ~ distance, ea, mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
term1
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
# term 1: decrease in signal amplitude (RMS) of reference (Ref) vs re-recorded (RR)
# term1 <- sig_RMS_REF - Y$sigRMS
term1 <- -20 * log10(sig_RMS_REF / Y$sigRMS)
term1
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
term1
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
term1
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 2, pb = F), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Darden"), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Darden"), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Marte"), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Marten"), mean)
20 * log10(102.5 / 2.5)
# lost due to spheric spreading
term2 <- 20 * log10(Y$distance - dist_REF)
term2
term2 <- -20 * log10(1 / Y$distance)
term2
term1 + term2
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Marten"), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Darden"), mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, pb = F, type = "Darden"), mean)
source("~/Dropbox/R_package_testing/baRulho/baRulho/R/excess_attenuation.R")
