funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#big data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
# run all fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R$", path = "./R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
run.all()
FUN <- "excess_attenuation"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = playback_est
print("using method 1")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
View(ea)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
print("using method 2")
ea2 <- excess_attenuation(X = playback_est, method = 1)
ea2
ea2$excess.attenuation
print("using method 1 and type  2")
(ea <- excess_attenuation(X = playback_est, type = "Darden"))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1, type = "Darden"), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 2, type = "Darden"), mean)
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 2, type = "Marten"), mean)
excess_attenuation(X = playback_est, method = 2, type = "Marten")
excess_attenuation(X = playback_est, method = 2, type = "Marten")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 2, type = "Marten"), mean)
excess_attenuation(X = playback_est, method = 2, type = "Marten")
aggregate(excess.attenuation ~ distance, excess_attenuation(X = playback_est, method = 1), mean)
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
aggregate(excess.attenuation ~ distance, ea2, mean)
print("using method 2")
ea2 <- excess_attenuation(X = playback_est, method = 2)
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
aggregate(excess.attenuation ~ distance, ea, mean)
ea$excess.attenuation
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
print("using method 2")
ea2 <- excess_attenuation(X = playback_est, method = 2)
ea2
ea2$excess.attenuation
X = playback_est
method = 2
X = playback_est
# is extended sel tab
if (!warbleR::is_extended_selection_table(X))
stop("'X' must be and extended selection table")
# If parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
#check output
if (!any(output %in% c("est", "data.frame"))) stop("'output' must be 'est' or 'data.frame'")
# hopsize
if (!is.numeric(hop.size) | hop.size < 0) stop("'hop.size' must be a positive number")
# adjust wl based on hope.size
if (is.null(wl))
wl <- round(attr(X, "check.results")$sample.rate[1] * hop.size, 0)
# make wl even if odd
if (!(wl %% 2) == 0) wl <- wl + 1
# If method is not numeric
if (!is.numeric(method)) stop("'method' must be a numeric vector of length 1")
if (!any(method %in% 1:2)) stop("'method' must be either 1 or 2")
# check signal.type column
if (is.null(X$signal.type)) stop("'X' must containe a 'signal.type' column")
# add sound file selec column and names to X (weird column name so it does not overwrite user columns)
if (pb)
write(file = "", x = paste0("Preparing data for analysis (step 1 out of 3):"))
X <- prep_X_bRlo_int(X, method = method, parallel = parallel, pb = pb)
# # function to measure RMS for signal and noise
spl_FUN <- function(y, wl, ovlp){
# read signal clip
clp <- warbleR::read_wave(X = X, index = y, from = 0, to = X$end[y])
# define bandpass based on reference
# bp <- c(X$bottom.freq[X$TEMP....sgnl == X$reference[y]], X$top.freq[X$TEMP....sgnl == X$reference[y]])
# bandpass filter
# clp <- seewave::ffilter(clp, from = bp[1] * 1000,
# ovlp = ovlp, to = bp[2] * 1000, bandpass = TRUE,
# wl = wl, output = "Wave")
# sig_clp <- cutw()
# get RMS for signal
sigRMS <- seewave::rms(seewave::env(clp, f = clp@samp.rate, envt = "abs", plot = FALSE))
sigSPL <- 20 * log10(sigRMS)
# measure ambient SPL
# read noise before signal
if (X$signal.type[y] != "ambient"){
noise_clp <- warbleR::read_wave(X = X, index = y, from = 0, to = X$start[y]- 0.001)
noiseRMS <- seewave::rms(seewave::env(noise_clp, f = noise_clp@samp.rate, envt = "abs", plot = FALSE))
noiseSPL <- 20 * log10(noiseRMS)
# remove noise SPL from signal SPL
sigSPL <- lessdB(signal.noise = sigSPL, noise = noiseSPL)
}
return(data.frame((X[y, , drop = FALSE]), sigSPL))
}
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
if (pb)
write(file = "", x = paste0("Measuring sound pressure level (step 2 out of 3):"))
# run loop apply function
SPLs <- warbleR:::pblapply_wrblr_int(X = 1:nrow(X), pbar = pb, cl = cl, FUN = function(y)  spl_FUN(y, wl, ovlp))
# put in a data frame
SPL_df <- do.call(rbind, SPLs)
# split by signal ID
SPL_list <- split(SPL_df, SPL_df$signal.type)
if (pb)
write(file = "", x = paste0("Calculating excess attenuation (step 3 out of 3):"))
SPL_list
Y
Y <- SPL_list[[2]]
Y
# save original order
Y$org....ord <- 1:nrow(Y)
# sort by distance
Y <- Y[order(Y$distance), ]
Y
# term 1: decrease in signal amplitude (RMS) of reference (Ref) vs re-recorded (RR)
term1 <- Y$sigSPL[-nrow(Y)] - Y$sigSPL[-1]
# lost due to spheric spreading
term2 <- 20 * log10(Y$distance[-1] / Y$distance[-nrow(Y)])
# ea <- observed_attenuation - expected_attenuation
ea <- (term2 - term1)
# add NA for first distance
ea <- c(NA, ea)
ea
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
ea2 <- excess_attenuation(X = playback_est, method = 2)
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
print("using method 1 and type  2")
(ea <- excess_attenuation(X = playback_est, type = "Darden"))
ea$excess.attenuation
print("using method 2 and Darden")
ea2 <- excess_attenuation(X = playback_est, method = 2, type = "Darden")
ea2
ea2$excess.attenuation
print("using method 2 and Darden")
ea2 <- excess_attenuation(X = playback_est, method = 2, type = "Darden")
ea2
ea2$excess.attenuation
(ea <- excess_attenuation(X = playback_est, type = "Darden"))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
print("using method 2 and Darden")
ea2 <- excess_attenuation(X = playback_est, method = 2, type = "Darden")
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
#tests
X = playback_est
print("using method 1")
(ea <- excess_attenuation(X = playback_est, method = 1))
playback_est
(ea <- excess_attenuation(X = playback_est, method = 1))
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
print("using method 1")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
print("using method 2")
ea2 <- excess_attenuation(X = playback_est, method = 2)
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
print("using method 1 and type  2")
(ea <- excess_attenuation(X = playback_est, type = "Darden"))
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
print("using method 1 and type  2")
(ea <- excess_attenuation(X = playback_est, type = "Darden"))
ea <- excess_attenuation(X = playback_est, type = "Darden")
ea <- excess_attenuation(X = playback_est, type = "Darden")
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
print("using method 2 and Darden")
ea2 <- excess_attenuation(X = playback_est, method = 2, type = "Darden")
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
print("all is good!")
ea2 <- excess_attenuation(X = playback_est, method = 2, type = "Darden")
print("using method 1 and type  2")
ea <- excess_attenuation(X = playback_est, type = "Darden")
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
source("~/Dropbox/R_package_testing/baRulho/R/excess_attenuation.R")
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#built site
pkgdown::build_site(lazy = TRUE)
FUN <- "atmospheric_attenuation"
#run function
run.all()
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# set temporary directory
td <- tempdir()
#tests
atmospheric_attenuation(f = 20000, temp = 20, RH = 90, p = 88000, formula = 1)
#tests
atmospheric_attenuation(f = 20000, temp = 20, RH = 90, p = 88000, formula = 1, dist = 10)
#tests
atmospheric_attenuation(f = 20000, temp = 20, RH = 90, p = 88000, formula = 1, dist = 10, spi = 80)
rm(list = ls())
#
# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))
x <- c("RColorBrewer", "devtools", "seewave", "maRce10/warbleR", "monitoR", "pkgdown", "ape", "spelling", "ggplot2", "png", "viridis")
out <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
install()
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
FUN <- "excess_attenuation"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = playback_est
#open function in rstudio
open.fun <- function(fun) system(paste("rstudio", file.path("./R", paste0(fun, ".R"))))
# run default arguments in a function
run.def.args <- function(fun = NULL){
#list functions in package
rfiles <- list.files(pattern = ".R", path = "./R", full.names = T)
# select target function file
funfile <- rfiles[gsub(".R", "", basename(rfiles)) == fun]
x <- readLines(funfile, warn = F)
st <- grep('@usage', x, fixed = T)
en <- grep('@param', x, fixed = T)[1]
x <- paste(x[st:(en-1)], collapse = " ")
x <- gsub("usage|\\@|\\#\\'", "", x)
b <- gregexpr(pattern ='\\(|\\)',x)[1][[1]]
x <- substr(x, start = b[1] + 1, stop = b[length(b)] - 1)
spltx <- strsplit(x, "\\,")[[1]]
sl <- vector()
y = 1
while(y <= length(spltx))
{
w <- spltx[y]
z <- 1
if(grepl('\\(', spltx[y]))
{z  <- 0
while(!grepl('\\)', w))
{
z <- z+ 1
w <- paste(w, ",", spltx[y + z], collapse = "")
}
z <- z + 1
}
y = y + z
sl[length(sl) + 1] <- w
}
sl <- sl[sl != "X"]
return(sl)
}
# run it like this:
# for(i in run.def.args("dfts")) try(eval(parse(text = i)), silent = T)
# remove sound files and or image files
rm.sf <- function() unlink(list.files(path = tempdir(), pattern = "\\.wav$", ignore.case = T, full.names = TRUE))
rm.sf.img <- function(mp3 = TRUE) {if(mp3)
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.mp3$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE)) else
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE))}
rm.img <- function() unlink(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$|\\.pdf$", ignore.case = T, full.names = TRUE))
#open latest image
last.img <- function() system(paste("eog", list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)))]
))
#open pdf
last.pdf <- function() system(paste("xdg-open", list.files(path = tempdir(), pattern = "\\.pdf$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.pdf", ignore.case = T, full.names = TRUE)))]
))
#find text in functions
find.text <- function(pattern, fun.only = FALSE, path = "./R", ignore.case = T)
{
rfiles <- list.files(pattern = "\\.R$|\\.Rmd$", path = path, full.names = T, all.files = T)
#check where a word is found in each function an return the name of function where it was found and the time
res <- NULL
w <- 1
for(f in rfiles){
x <- readLines(f)
y <- grep(pattern, x, fixed = T, value = T, ignore.case = ignore.case)
if(length(y)>0 & !fun.only) {
print(gsub(pattern = "\\.R", "", (basename(f))))
for(i in y) print(i)
}
if(length(y)>0 & fun.only) res[w] <- gsub(pattern = "\\.R", "", (basename(f)))
# options(nwarnings = 0)
w = w + 1
}
if(fun.only)
{res <- res[!is.na(res)]
return(res)}
}
#replace text
repl.text <- function(pattern, repl, path = "./R", ignore.case = T){
rfiles <- list.files(pattern = "\\.R$|\\.Rmd", path = path, full.names = T, all.files = T)
for(f in rfiles){
#find and replace
x <- readLines(f)
y <- gsub(pattern, repl, x, fixed = T, ignore.case = ignore.case)
cat(y, file=f, sep="\n")
#reread
x <- readLines(f)
w <- grep(repl, x, fixed = T, value = T, ignore.case = T)
if(length(w)>0) {
print(f)
for(i in w) print(i)
}
}
}
#find functions with specific arguments
find.arg <- function(arg1, arg2 = NULL){
rfiles <- list.files(pattern = "\\.R$", path = "./R", full.names = T, all.files = T)
funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#big data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
# run all fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R$", path = "./R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
run.all()
FUN <- "excess_attenuation"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = playback_est
print("using method 1")
(ea <- excess_attenuation(X = playback_est, method = 1))
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
print("using method 2")
ea2 <- excess_attenuation(X = playback_est, method = 2)
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
print("using method 1 and type  2")
ea <- excess_attenuation(X = playback_est, type = "Darden")
ea$excess.attenuation
aggregate(excess.attenuation ~ distance, ea, mean)
print("using method 2 and Darden")
ea2 <- excess_attenuation(X = playback_est, method = 2, type = "Darden")
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
aggregate(excess.attenuation ~ distance, ea2, mean, type= "Dabelsteen")
ea2 <- excess_attenuation(X = playback_est, method = 2, type= "Dabelsteen")
ea2
ea2$excess.attenuation
aggregate(excess.attenuation ~ distance, ea2, mean)
