# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = degradation_est[degradation_est$sound.files != "master.wav" & degradation_est$sound.id != "ambient", ]
names(X)
View(X)
row.names(degradation_est)
rownames(degradation_est)
rownames(degradation_est) <- 1:nrow(degradation_est)
save(degradation_est, file="./data/degradation_est.rda", version = 2, compress = "xz")
#tests
X = degradation_est[degradation_est$sound.files != "master.wav" & degradation_est$sound.id != "ambient", ]
load("./data/degradation_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = degradation_est[degradation_est$sound.files != "master.wav" & degradation_est$sound.id != "ambient", ]
X
View(X)
master_annotations <- read.csv("./testing/example_data/tlalpan/master_annotations.csv")
# directory path where supplementary files have been saved
options(sound.files.path = "./testing/example_data/tlalpan", dest.path = "./testing/example_data/tlalpan")
master_annotations <- rbind(master_annotations[1, ], master_annotations)
master_annotations$sound.id[1] <- "ambient"
master_annotations$end[1] <- master_annotations$start[1] - 0.05
master_annotations$start[1] <- master_annotations$start[1] - 0.2
master_annotations$selec <- 1:nrow(master_annotations)
markers_in_tests <-
find_markers(X = master_annotations, cores = 10, wl = 50)  # annotations of sounds in master
aligned_tests <-
align_test_files(X = master_annotations, # annotations of sounds in master file
Y = markers_in_tests, remove.markers = FALSE)
plot_align_sounds(X = aligned_tests, srt = 10, duration = 4)
intrsc <- intersect(names(master_annotations), names(aligned_tests))
anns <- rbind(master_annotations[, intrsc], aligned_tests[, intrsc])
out <- lapply(unique(anns$sound.files), function(i){
sub_anns <- anns[anns$sound.files == i, ]
wav <- read_wave(X = sub_anns, from = 0, to = Inf, index = 1, path = "./testing/example_data/tlalpan")
diff <- 0.25
wav <- cutw(wav, from = sub_anns$start[sub_anns$sound.id == "start_marker"] - diff, to = sub_anns$start[sub_anns$sound.id == "dur:0.2;freq:9.5;fm;am_1"], output = "Wave")
# spectro(wav, osc = FALSE, scale = FALSE, collevels = seq(-120, 0, 5))
wav_end <- read_wave(X = sub_anns, from = sub_anns$start[which(sub_anns$sound.id == "end_marker")], to = sub_anns$end[which(sub_anns$sound.id == "end_marker")] + 0.1, index = which(sub_anns$sound.id == "end_marker"), path = "./testing/example_data/tlalpan")
# spectro(wav_end, osc = FALSE, scale = FALSE, collevels = seq(-120, 0, 5))
new_wav <- pastew(wav_end, wav, output = "Wave")
spectro(new_wav, osc = FALSE, scale = FALSE, collevels = seq(-120, 0, 5))
writeWave(new_wav, filename = file.path("./testing/example_data/tailored_files_tlalpan", gsub("trnsc1_", "", i)))
sub_anns2 <- sub_anns[1:7, ]
sub_anns2$start <- sub_anns2$start - (sub_anns2$start[sub_anns2$sound.id == "start_marker"] - diff)
sub_anns2$end <- sub_anns2$end - (sub_anns$start[sub_anns$sound.id == "start_marker"] - diff)
sub_anns2$sound.id[7] <- "end_marker"
sub_anns2$end[7] <- sub_anns2$start[7] + (sub_anns$end[sub_anns$sound.id == "end_marker"] - sub_anns$start[sub_anns$sound.id == "end_marker"])
sub_anns2$sound.files <- gsub("trnsc1_", "", sub_anns2$sound.files)
abline(v = c(sub_anns2$start, sub_anns2$end))
return(sub_anns2)
}
)
alg <- do.call(rbind, out)
alg$transect <- NA
alg$transect <- ifelse(grepl("open", alg$sound.files), "open", alg$transect)
alg$transect <- ifelse(grepl("closed", alg$sound.files), "closed", alg$transect)
alg$distance <- NA
alg$distance <- ifelse(grepl("30m", alg$sound.files), 30, alg$distance)
alg$distance <- ifelse(grepl("1m", alg$sound.files), 1, alg$distance)
alg$distance <- ifelse(grepl("10m", alg$sound.files), 10, alg$distance)
alg <- alg[alg$sound.files == "master.wav" | alg$sound.files != "master.wav" & !grepl("marker", alg$sound.id), ]
alg$sound.id
alg$sound.id <- gsub(";fm;am_1", "", alg$sound.id)
alg$sound.id
alg$sound.id <- gsub("dur:0.2:", "", alg$sound.id)
alg$sound.id
alg$sound.id <- gsub(";fm;am_1", "", alg$sound.id)
alg$sound.id <- gsub("dur:0.2;", "", alg$sound.id)
alg$sound.id
write.csv(alg[alg$sound.files == "master.wav", ], "./testing/example_data/tailored_files_tlalpan/master_annotations.csv", row.names = FALSE)
write.csv(alg[alg$sound.files != "master.wav" & !grepl("marker", alg$sound.id), ], "./testing/example_data/tailored_files_tlalpan/aligned_annotations.csv", row.names = FALSE)
degradation_est <- selection_table(alg, path = "./testing/example_data/tailored_files_tlalpan/", extended = TRUE, by.song = "sound.files", mar = 10, confirm.extended = FALSE)
degradation_est <- rename_waves_est(X = degradation_est, new.sound.files = sapply(strsplit(names(attr(degradation_est, 'wave.objects')), "-song"), "[[", 1))
degradation_est$old.sound.file.name <- NULL
rownames(degradation_est) <- 1:nrow(degradation_est)
save(degradation_est, file="./data/degradation_est.rda", version = 2, compress = "xz")
FUN <- "blur_ratio"
#run function
run.all()
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/degradation_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
X = degradation_est[degradation_est$sound.files != "master.wav" & degradation_est$sound.id != "ambient", ]
print("basic")
a <- blur_ratio(X = X, cores = 2, method = 2)
method = 2
cores = 1
pb = T
# add sound file selec colums to X (weird column name so it does not overwrite user columns)
X$.sgnl.temp <- paste(X$sound.files, X$selec, sep = "-")
# make it a regular data frame (no est)
X2 <- as.data.frame(X)
cl <- cores
nrow(X)
View(X2)
a <- blur_ratio(X = X, cores = 2, method = 2)
a <- blur_ratio(X = X, cores = 2, method = 1)
which.min(c(1, 1, 34))
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
x = 1
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
a <- blur_ratio(X = X, cores = 2, method = 1)
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
print("basic")
a <- blur_ratio(X = X, cores = 2, method = 1)
print("method 2")
a <- blur_ratio(X = X, cores = 2, method = 2)
a <- blur_ratio(X = X, cores = 2, method = 1)
View(a)
print("method 2")
a <- blur_ratio(X = X, cores = 2, method = 2)
warnings()
View(a)
a2 <- blur_ratio(X = X, cores = 2, method = 2)
a2 <- blur_ratio(X = X, cores = 1, method = 2)
#tests
X = degradation_est[degradation_est$sound.files != "master.wav" & degradation_est$sound.id != "ambient", ]
# add sound file selec colums to X (weird column name so it does not overwrite user columns)
X$.sgnl.temp <- paste(X$sound.files, X$selec, sep = "-")
# make it a regular data frame (no est)
X2 <- as.data.frame(X)
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != W$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
print(x)
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != W$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
x = 13
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
meth == 1
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W
W <- W[order(W$distance), ]
W
X2$.sgnl.temp[x]
# add sound file selec colums to X (weird column name so it does not overwrite user columns)
X$.sgnl.temp <- X$sound.id
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != W$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
x
# add sound file selec colums to X (weird column name so it does not overwrite user columns)
X$.sgnl.temp <- X$sound.id
# make it a regular data frame (no est)
X2 <- as.data.frame(X)
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
W
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W
W <- W[order(W$distance), ]
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
a <- blur_ratio(X = X, cores = 2, method = 1)
print("method 2")
a2 <- blur_ratio(X = X, cores = 1, method = 2)
W
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
print(x)
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != W$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
x = 3
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
W$.sgnl.temp[1]
W$.sgnl.temp[x]
x
W$.sgnl.temp[1] != X2$.sgnl.temp[x]
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
a2 <- blur_ratio(X = X, cores = 1, method = 2)
View(a2)
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != X2$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
X
X$reference
z
# add sound file selec colums to X (weird column name so it does not overwrite user columns)
X$.sgnl.temp <- paste(X$sound.files, X$selec, sep = "-")
# make it a regular data frame (no est)
X2 <- as.data.frame(X)
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & cores > 1) {
cl <- parallel::makePSOCKcluster(getOption("cl.cores", cores))
} else {
cl <- cores
}
# set pb options
pbapply::pboptions(type = ifelse(as.logical(pb), "timer", "none"))
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != X2$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
X$reference
View(X)
method
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
W
# if method 2
# get those from the same transect and same sound id
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
W
W$.sgnl.temp[1] != X2$.sgnl.temp[x]
W$.sgnl.temp[1]
W$.sgnl.temp[1]
X2$.sgnl.temp[x]
W$.sgnl.temp[1]
method = 2
# add second column with names of the reference sounds to be compared against
X$reference <-
pbapply::pbsapply(seq_len(nrow(X)), cl = cl, function(x, meth = method) {
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) {
# if column transect if found select the lowest distance in that trasnect
if (!is.null(X2$transect)){
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
# if there is another distance that is shorter in other transects for that signal, use that distance
z <- if (which.min(W$distance) <= which.min(Y$distance))
W$.sgnl.temp[which.min(W$distance)] else Y$.sgnl.temp[which.min(Y$distance)]
} else
z <- Y$.sgnl.temp[which.min(Y$distance)]
} else {
# if method 2
# get those from the same transect and same sound id
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == X2$.sgnl.temp[x]] & X2$sound.id == X$sound.id[X2$.sgnl.temp == X2$.sgnl.temp[x]], , drop = FALSE]
W <- W[order(W$distance), ]
# if not the first row then the previous row
if (W$.sgnl.temp[1] != X2$.sgnl.temp[x]) {
z <- X$.sgnl.temp[x - 1]
} else {
# else the first row
z <- W$.sgnl.temp[1]
}
}
return(z)
})
View(X)
X <- X[order(X$sound.id, X$transect, X$distance)]
X <- X[order(X$sound.id, X$transect, X$distance),]
View(X)
W
X2$.sgnl.temp[x]
W$.sgnl.temp[1]
W$.sgnl.temp[1]
W$.sgnl.temp[1] != X2$.sgnl.temp[x]
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
print("basic")
a <- blur_ratio(X = X, cores = 2, method = 1)
print("method 2")
a2 <- blur_ratio(X = X, cores = 1, method = 2)
View(a2)
source("~/Dropbox/R_package_testing/baRulho/R/spectrum_correlation.R")
a <- blur_ratio(X = X, cores = 2, method = 1)
print("method 2")
a <- blur_ratio(X = X, cores = 2, method = 1)
View(a)
View(a2)
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
source("~/Dropbox/R_package_testing/baRulho/R/blur_ratio.R")
a <- blur_ratio(X = X, cores = 2, method = 1)
View(a)
a2 <- blur_ratio(X = X, cores = 1, method = 2)
View(a2)
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
a <- blur_ratio(X = X, cores = 2, method = 1)
View(a)
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
#tests
X = degradation_est[degradation_est$sound.files != "master.wav" & degradation_est$sound.id != "ambient", ]
# add sound file selec colums to X (weird column name so it does not overwrite user columns)
X$.sgnl.temp <- paste(X$sound.files, X$selec, sep = "-")
# make it a regular data frame (no est)
X2 <- as.data.frame(X)
X
X2
10m_closed.wav-4
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == x], , drop = FALSE]
Y <- Y[order(Y$distance), ]
x <- "10m_closed.wav-4"
# extract for single sound id and order by distance
Y <-
X2[X2$sound.id == X$sound.id[X2$.sgnl.temp == x], , drop = FALSE]
Y <- Y[order(Y$distance), ]
W <- X2[X2$transect == X2$transect[X2$.sgnl.temp == x] & X2$sound.id == X$sound.id[X2$.sgnl.temp == x], , drop = FALSE]
W
which.min(W$distance) <= which.min(Y$distance)
W$.sgnl.temp[which.min(W$distance)]
which.min(Y$distance)
which.min(W$distance)
W
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
source("~/Dropbox/R_package_testing/baRulho/R/internal_functions.R")
a <- blur_ratio(X = X, cores = 2, method = 1)
View(a)
styler::style_dir("./R")
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE, vignettes = F)
